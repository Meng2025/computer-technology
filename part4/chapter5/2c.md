---
sort: 2
---
# C 语言编程实践

假设已经熟练使用各种 C 语言机制

**原则上**给需求就能搞定任何代码，比如说模拟器，操作系统，编译器。

但是原理上很简单的东西，并不容易做出来，编写一个足够大的项目也是有些准则的。

- 怎样写代码才能从一个大型项目里存活下来？
  - 核心准则：编写可读代码
  - 两个例子


## 核心准则：写一个能看的代码

怎么维护一个比较大的，给人看的代码。这样才能让人看得懂，让更多人参与进来。

一个极端的代码不可读的例子：

```c
#include <stdio.h>
#include <math.h>
#define clear 1;if(c>=11){c=0;sscanf(_,"%lf%c",&r,&c);while(*++_-c);}\
  else if(argc>=4&&!main(4-(*_++=='('),argv))_++;g:c+=
#define puts(d,e) return 0;}{double a;int b;char c=(argc<4?d)&15;\
  b=(*_%__LINE__+7)%9*(3*e>>c&1);c+=
#define I(d) (r);if(argc<4&&*#d==*_){a=r;r=usage?r*a:r+a;goto g;}c=c
#define return if(argc==2)printf("%f\n",r);return argc>=4+
#define usage main(4-__LINE__/26,argv)
#define calculator *_*(int)
#define l (r);r=--b?r:
#define _ argv[1]
#define x

double r;
int main(int argc,char** argv){
  if(argc<2){
    puts(
      usage: calculator 11/26+222/31
      +~~~~~~~~~~~~~~~~~~~~~~~~calculator-\
      !                          7.584,367 )
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! clear ! 0 ||l   -x  l   tan  I (/) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 1 | 2 | 3 ||l  1/x  l   cos  I (*) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 4 | 5 | 6 ||l  exp  l  sqrt  I (+) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
      ! 7 | 8 | 9 ||l  sin  l   log  I (-) |
      +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(0
    );
  }
  return 0;
}
```
怎么说呢，很好看的一坨屎，最后能用。

这是一段完全不可读的代码，不可读的含义：
- 根本看不出设计者的思路
- 如果要新增一个运算符，基本上需要推倒重来


一个现实里可以遇到的例子，人类不可读：

```c
void (*signal(int sig, void (*func)(int)))(int);
```

一段代码自己直到是怎么回事，那么过一个月再看呢？

C语言提供了很多机制，让不可读变得可读

```c
/* 定义一个函数指针的类型 */
typedef void (*sighandler_t)(int);

/* 从此以后，这个类型有了个小名 */
sighandler_t signal(int, sighandler_t);
```

这是个真实存在的函数，在Linux手册里，可以看到，终端输入`man 2 signal`。

为啥按`ctrl + c`的时候程序会推出呢，但是vim和man又不能用这个指令退出。实际上终端向进程发送了一个信号，这个函数就是去注册一个信号。我们可以改变按键的默认操作。

通过这个函数我们可以设置一个自己的函数，在按`ctrl + c`的时候printf个啥东西。

最重要的，对比上下两个代码，下面的对人类更友好。

写代码的基本准则：降低维护成本

```c
Programs are meant to be read by humans and only incidentally for computers to execute. — D. E. Knuth

(程序首先是拿给人读的，其次才是被机器执行。)
```

项目越大，这个问题会越突出。大的方面来讲，问题的分解，在写头文件的时候就应该想好（含义是一个功能先写头文件）。

宏观
- 做好分解和解耦 (现实世界也是这样管理复杂系统的)

微观
- “不言自明”
  - 通过阅读代码能理解一段程序是做什么的 (specification)
- “不言自证”
  - 通过阅读代码能验证一段程序与 specification 的一致性

代码的更高要求，基本上不需要注释，看到代码就知道输入是啥，输出是啥，还能感觉到


## 例子：实现数字逻辑电路模拟器

假想的数字逻辑电路：
- 若干个 1-bit 边沿触发寄存器 (X, Y, ...)
- 若干个逻辑门

做一个0、1、2的计数器，在时钟到来时00→01→10来回循环。

- 基本的思路，状态模拟 + 计算模拟。（状态就是存储）
  - 状态 = 变量
    - int X = 0, Y = 0;
  - 计算
    - X1 = !X && Y;
    - Y1 = !X && !Y;
    - X = X1; Y = Y1;

然后再这个while循环里，不断走。通过这个方式基本上可以模拟任意一个数字电路。


```note
比如3位，做一个模5计数器。
- int X = 0, Y = 0, Z = 0;
- X1 = !X && Y && Z;
- Y1 = 

```

存在的问题是，不好扩展，项目变大，一改需求就完了。而且这种代码，一不小心，逻辑错了，还是挺难改的。各种各样的逻辑分布在不同的文件，加一个逻辑改5个地方都挺难受的。



